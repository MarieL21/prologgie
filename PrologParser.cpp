/** \file
 *  This C++ source file was generated by $ANTLR version 3.5
 *
 *     -  From the grammar source file : Prolog.g
 *     -                            On : 2013-10-17 13:42:20
 *     -                for the parser : PrologParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "PrologParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

	namespace 	User  {

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   PrologParserTokenNames[15+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "ATOM",
        (ANTLR_UINT8*) "DIGIT",
        (ANTLR_UINT8*) "LOWERCASE",
        (ANTLR_UINT8*) "NUMBER",
        (ANTLR_UINT8*) "PRIME",
        (ANTLR_UINT8*) "SPECIAL",
        (ANTLR_UINT8*) "UNDERSCORE",
        (ANTLR_UINT8*) "UPPERCASE",
        (ANTLR_UINT8*) "VARIABLE",
        (ANTLR_UINT8*) "WS",
        (ANTLR_UINT8*) "'('",
        (ANTLR_UINT8*) "')'",
        (ANTLR_UINT8*) "','",
        (ANTLR_UINT8*) "'.'",
        (ANTLR_UINT8*) "':-'"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "Prolog.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* PrologParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new PrologParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PrologParser::PrologParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new PrologParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PrologParser::PrologParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void PrologParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( PrologParserTokenNames );


}

void
PrologParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
PrologParser::~PrologParser()
 {
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return PrologParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_fact_in_program93_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000012) };
static  PrologParserImplTraits::BitsetListType FOLLOW_fact_in_program93( FOLLOW_fact_in_program93_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_rule_in_program97_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000012) };
static  PrologParserImplTraits::BitsetListType FOLLOW_rule_in_program97( FOLLOW_rule_in_program97_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_query_in_program101_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000012) };
static  PrologParserImplTraits::BitsetListType FOLLOW_query_in_program101( FOLLOW_query_in_program101_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_functor_in_comp_term122_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_functor_in_comp_term122( FOLLOW_functor_in_comp_term122_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_14_in_comp_term124_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001090) };
static  PrologParserImplTraits::BitsetListType FOLLOW_14_in_comp_term124( FOLLOW_14_in_comp_term124_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_term_in_comp_term126_bits[]	= { ANTLR_UINT64_LIT(0x0000000000018000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_term_in_comp_term126( FOLLOW_term_in_comp_term126_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_16_in_comp_term129_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001090) };
static  PrologParserImplTraits::BitsetListType FOLLOW_16_in_comp_term129( FOLLOW_16_in_comp_term129_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_term_in_comp_term131_bits[]	= { ANTLR_UINT64_LIT(0x0000000000018000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_term_in_comp_term131( FOLLOW_term_in_comp_term131_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_15_in_comp_term135_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_15_in_comp_term135( FOLLOW_15_in_comp_term135_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_NUMBER_in_term148_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_NUMBER_in_term148( FOLLOW_NUMBER_in_term148_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_VARIABLE_in_term169_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_VARIABLE_in_term169( FOLLOW_VARIABLE_in_term169_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_term188_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_term188( FOLLOW_ATOM_in_term188_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_comp_term_in_term209_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_comp_term_in_term209( FOLLOW_comp_term_in_term209_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_functor234_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_functor234( FOLLOW_ATOM_in_functor234_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_fact264_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_fact264( FOLLOW_ATOM_in_fact264_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_comp_term_in_fact283_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_comp_term_in_fact283( FOLLOW_comp_term_in_fact283_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_17_in_fact286_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_17_in_fact286( FOLLOW_17_in_fact286_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_rule312_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_rule312( FOLLOW_ATOM_in_rule312_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_comp_term_in_rule316_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_comp_term_in_rule316( FOLLOW_comp_term_in_rule316_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_18_in_rule319_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000010) };
static  PrologParserImplTraits::BitsetListType FOLLOW_18_in_rule319( FOLLOW_18_in_rule319_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_rule322_bits[]	= { ANTLR_UINT64_LIT(0x0000000000030000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_rule322( FOLLOW_ATOM_in_rule322_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_comp_term_in_rule326_bits[]	= { ANTLR_UINT64_LIT(0x0000000000030000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_comp_term_in_rule326( FOLLOW_comp_term_in_rule326_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_16_in_rule330_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000010) };
static  PrologParserImplTraits::BitsetListType FOLLOW_16_in_rule330( FOLLOW_16_in_rule330_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_rule333_bits[]	= { ANTLR_UINT64_LIT(0x0000000000030000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_rule333( FOLLOW_ATOM_in_rule333_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_comp_term_in_rule337_bits[]	= { ANTLR_UINT64_LIT(0x0000000000030000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_comp_term_in_rule337( FOLLOW_comp_term_in_rule337_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_17_in_rule342_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_17_in_rule342( FOLLOW_17_in_rule342_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_query365_bits[]	= { ANTLR_UINT64_LIT(0x0000000000030000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_query365( FOLLOW_ATOM_in_query365_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_comp_term_in_query369_bits[]	= { ANTLR_UINT64_LIT(0x0000000000030000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_comp_term_in_query369( FOLLOW_comp_term_in_query369_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_16_in_query373_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000010) };
static  PrologParserImplTraits::BitsetListType FOLLOW_16_in_query373( FOLLOW_16_in_query373_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_query376_bits[]	= { ANTLR_UINT64_LIT(0x0000000000030000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_query376( FOLLOW_ATOM_in_query376_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_comp_term_in_query380_bits[]	= { ANTLR_UINT64_LIT(0x0000000000030000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_comp_term_in_query380( FOLLOW_comp_term_in_query380_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_17_in_query385_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_17_in_query385( FOLLOW_17_in_query385_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_fact_in_synpred1_Prolog93_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_fact_in_synpred1_Prolog93( FOLLOW_fact_in_synpred1_Prolog93_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_rule_in_synpred2_Prolog97_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_rule_in_synpred2_Prolog97( FOLLOW_rule_in_synpred2_Prolog97_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_query_in_synpred3_Prolog101_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_query_in_synpred3_Prolog101( FOLLOW_query_in_synpred3_Prolog101_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start program
 * Prolog.g:38:1: program : ( fact | rule | query )+ ;
 */
void
PrologParser::program()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // Prolog.g:38:9: ( ( fact | rule | query )+ )
        // Prolog.g:38:11: ( fact | rule | query )+
        {
            // Prolog.g:38:11: ( fact | rule | query )+
            {
                int cnt1=0;

                for (;;)
                {
                    int alt1=4;
            	switch ( this->LA(1) )
            	{
            	case ATOM:
            		{
            			{
            			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            			    */
            			    int LA1_2 = this->LA(2);
            			    if ( (this->msynpred( antlr3::ClassForwarder<synpred1_Prolog>() )))
            			    {
            			        alt1=1;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred2_Prolog>() )))
            			    {
            			        alt1=2;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred3_Prolog>() )))
            			    {
            			        alt1=3;
            			    }

            			}
            		}
            	    break;

            	}

            	switch (alt1)
            	{
            	    case 1:
            	        // Prolog.g:38:12: fact
            	        {
            	            this->followPush(FOLLOW_fact_in_program93);
            	            fact();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleprogramEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;
            	    case 2:
            	        // Prolog.g:38:19: rule
            	        {
            	            this->followPush(FOLLOW_rule_in_program97);
            	            rule();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleprogramEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;
            	    case 3:
            	        // Prolog.g:38:26: query
            	        {
            	            this->followPush(FOLLOW_query_in_program101);
            	            query();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleprogramEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt1 >= 1 )
            		{
            		    goto loop1;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PrologParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleprogramEx;
            	}
            	cnt1++;
                }
                loop1: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprogramEx; /* Prevent compiler warnings */
    ruleprogramEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end program */

/**
 * $ANTLR start comp_term
 * Prolog.g:41:1: comp_term : functor '(' term ( ',' term )* ')' ;
 */
void
PrologParser::comp_term()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // Prolog.g:41:13: ( functor '(' term ( ',' term )* ')' )
        // Prolog.g:41:15: functor '(' term ( ',' term )* ')'
        {
            this->followPush(FOLLOW_functor_in_comp_term122);
            functor();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecomp_termEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(14, &FOLLOW_14_in_comp_term124);
            if  (this->hasException())
            {
                goto rulecomp_termEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_term_in_comp_term126);
            term();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecomp_termEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // Prolog.g:41:32: ( ',' term )*

            for (;;)
            {
                int alt2=2;
                switch ( this->LA(1) )
                {
                case 16:
                	{
                		alt2=1;
                	}
                    break;

                }

                switch (alt2)
                {
            	case 1:
            	    // Prolog.g:41:33: ',' term
            	    {
            	         this->matchToken(16, &FOLLOW_16_in_comp_term129);
            	        if  (this->hasException())
            	        {
            	            goto rulecomp_termEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_term_in_comp_term131);
            	        term();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecomp_termEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop2;	/* break out of the loop */
            	    break;
                }
            }
            loop2: ; /* Jump out to here if this rule does not match */


             this->matchToken(15, &FOLLOW_15_in_comp_term135);
            if  (this->hasException())
            {
                goto rulecomp_termEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecomp_termEx; /* Prevent compiler warnings */
    rulecomp_termEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end comp_term */

/**
 * $ANTLR start term
 * Prolog.g:43:1: term : (n= NUMBER |v= VARIABLE |a= ATOM | comp_term );
 */
void
PrologParser::term()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    n;
    const CommonTokenType*    v;
    const CommonTokenType*    a;

    /* Initialize rule variables
     */

    n       = NULL;
    v       = NULL;
    a       = NULL;


 
    {
        {
            //  Prolog.g:43:9: (n= NUMBER |v= VARIABLE |a= ATOM | comp_term )

            ANTLR_UINT32 alt3;

            alt3=4;

            switch ( this->LA(1) )
            {
            case NUMBER:
            	{
            		alt3=1;
            	}
                break;
            case VARIABLE:
            	{
            		alt3=2;
            	}
                break;
            case ATOM:
            	{
            		switch ( this->LA(2) )
            		{
            		case EOF:
            		case 15:
            		case 16:
            			{
            				alt3=3;
            			}
            		    break;
            		case 14:
            			{
            				alt3=4;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 3 );
            		    ex->set_state( 3 );


            		    goto ruletermEx;

            		}

            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 3 );
                ex->set_state( 0 );


                goto ruletermEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // Prolog.g:43:11: n= NUMBER
        	    {
        	        n =  this->matchToken(NUMBER, &FOLLOW_NUMBER_in_term148);
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            m_ArgsScope_stack.peek().args.push_back((n->getText()));
        	        }


        	    }
        	    break;
        	case 2:
        	    // Prolog.g:44:11: v= VARIABLE
        	    {
        	        v =  this->matchToken(VARIABLE, &FOLLOW_VARIABLE_in_term169);
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            m_ArgsScope_stack.peek().args.push_back((v->getText()));
        	        }


        	    }
        	    break;
        	case 3:
        	    // Prolog.g:45:11: a= ATOM
        	    {
        	        a =  this->matchToken(ATOM, &FOLLOW_ATOM_in_term188);
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            m_ArgsScope_stack.peek().args.push_back((a->getText()));
        	        }


        	    }
        	    break;
        	case 4:
        	    // Prolog.g:46:11: comp_term
        	    {
        	        this->followPush(FOLLOW_comp_term_in_term209);
        	        comp_term();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruletermEx; /* Prevent compiler warnings */
    ruletermEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end term */

/**
 * $ANTLR start functor
 * Prolog.g:49:1: functor : ATOM ;
 */
void
PrologParser::functor()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // Prolog.g:49:9: ( ATOM )
        // Prolog.g:49:11: ATOM
        {
             this->matchToken(ATOM, &FOLLOW_ATOM_in_functor234);
            if  (this->hasException())
            {
                goto rulefunctorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunctorEx; /* Prevent compiler warnings */
    rulefunctorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end functor */

/**
 * $ANTLR start fact
 * Prolog.g:52:1: fact : (a= ATOM | comp_term ) '.' ;
 */
void
PrologParser::fact()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    a;

    /* Initialize rule variables
     */
    m_ArgsScope_stack.push(ArgsScopeScope()); 


        m_ArgsScope_stack.peek().args.clear();

    a       = NULL;


 
    {
        // Prolog.g:58:9: ( (a= ATOM | comp_term ) '.' )
        // Prolog.g:58:11: (a= ATOM | comp_term ) '.'
        {
            // Prolog.g:58:11: (a= ATOM | comp_term )
            {
                int alt4=2;
                switch ( this->LA(1) )
                {
                case ATOM:
                	{
                		switch ( this->LA(2) )
                		{
                		case 17:
                			{
                				alt4=1;
                			}
                		    break;
                		case 14:
                			{
                				alt4=2;
                			}
                		    break;

                		default:
                		    if (this->get_backtracking()>0)
                		    {
                		        this->set_failedflag( true );
                		        m_ArgsScope_stack.pop(); 

                		        return ;
                		    }

                		    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		    ex->set_decisionNum( 4 );
                		    ex->set_state( 1 );


                		    goto rulefactEx;

                		}

                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        m_ArgsScope_stack.pop(); 

                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 4 );
                    ex->set_state( 0 );


                    goto rulefactEx;

                }

                switch (alt4)
                {
            	case 1:
            	    // Prolog.g:58:12: a= ATOM
            	    {
            	        a =  this->matchToken(ATOM, &FOLLOW_ATOM_in_fact264);
            	        if  (this->hasException())
            	        {
            	            goto rulefactEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            m_ArgsScope_stack.pop(); 

            	            return ;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            m_ArgsScope_stack.peek().args.push_back((a->getText()));
            	        }


            	    }
            	    break;
            	case 2:
            	    // Prolog.g:59:16: comp_term
            	    {
            	        this->followPush(FOLLOW_comp_term_in_fact283);
            	        comp_term();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefactEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            m_ArgsScope_stack.pop(); 

            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(17, &FOLLOW_17_in_fact286);
            if  (this->hasException())
            {
                goto rulefactEx;
            }
            if (this->hasFailed())
            {
                m_ArgsScope_stack.pop(); 

                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                std::cout << "matched a fact!" << std::endl;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefactEx; /* Prevent compiler warnings */
    rulefactEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    m_ArgsScope_stack.pop(); 

    return ;
}
/* $ANTLR end fact */

/**
 * $ANTLR start rule
 * Prolog.g:64:1: rule : ( ATOM | comp_term ) ':-' ( ATOM | comp_term ) ( ',' ( ATOM | comp_term ) )* '.' ;
 */
void
PrologParser::rule()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // Prolog.g:65:3: ( ( ATOM | comp_term ) ':-' ( ATOM | comp_term ) ( ',' ( ATOM | comp_term ) )* '.' )
        // Prolog.g:65:3: ( ATOM | comp_term ) ':-' ( ATOM | comp_term ) ( ',' ( ATOM | comp_term ) )* '.'
        {
            // Prolog.g:65:3: ( ATOM | comp_term )
            {
                int alt5=2;
                switch ( this->LA(1) )
                {
                case ATOM:
                	{
                		switch ( this->LA(2) )
                		{
                		case 18:
                			{
                				alt5=1;
                			}
                		    break;
                		case 14:
                			{
                				alt5=2;
                			}
                		    break;

                		default:
                		    if (this->get_backtracking()>0)
                		    {
                		        this->set_failedflag( true );
                		        return ;
                		    }

                		    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		    ex->set_decisionNum( 5 );
                		    ex->set_state( 1 );


                		    goto ruleruleEx;

                		}

                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 5 );
                    ex->set_state( 0 );


                    goto ruleruleEx;

                }

                switch (alt5)
                {
            	case 1:
            	    // Prolog.g:65:4: ATOM
            	    {
            	         this->matchToken(ATOM, &FOLLOW_ATOM_in_rule312);
            	        if  (this->hasException())
            	        {
            	            goto ruleruleEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Prolog.g:65:11: comp_term
            	    {
            	        this->followPush(FOLLOW_comp_term_in_rule316);
            	        comp_term();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleruleEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(18, &FOLLOW_18_in_rule319);
            if  (this->hasException())
            {
                goto ruleruleEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // Prolog.g:65:27: ( ATOM | comp_term )
            {
                int alt6=2;
                switch ( this->LA(1) )
                {
                case ATOM:
                	{
                		switch ( this->LA(2) )
                		{
                		case 16:
                		case 17:
                			{
                				alt6=1;
                			}
                		    break;
                		case 14:
                			{
                				alt6=2;
                			}
                		    break;

                		default:
                		    if (this->get_backtracking()>0)
                		    {
                		        this->set_failedflag( true );
                		        return ;
                		    }

                		    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		    ex->set_decisionNum( 6 );
                		    ex->set_state( 1 );


                		    goto ruleruleEx;

                		}

                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 6 );
                    ex->set_state( 0 );


                    goto ruleruleEx;

                }

                switch (alt6)
                {
            	case 1:
            	    // Prolog.g:65:28: ATOM
            	    {
            	         this->matchToken(ATOM, &FOLLOW_ATOM_in_rule322);
            	        if  (this->hasException())
            	        {
            	            goto ruleruleEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Prolog.g:65:35: comp_term
            	    {
            	        this->followPush(FOLLOW_comp_term_in_rule326);
            	        comp_term();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleruleEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // Prolog.g:65:46: ( ',' ( ATOM | comp_term ) )*

            for (;;)
            {
                int alt8=2;
                switch ( this->LA(1) )
                {
                case 16:
                	{
                		alt8=1;
                	}
                    break;

                }

                switch (alt8)
                {
            	case 1:
            	    // Prolog.g:65:47: ',' ( ATOM | comp_term )
            	    {
            	         this->matchToken(16, &FOLLOW_16_in_rule330);
            	        if  (this->hasException())
            	        {
            	            goto ruleruleEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // Prolog.g:65:51: ( ATOM | comp_term )
            	        {
            	            int alt7=2;
            	            switch ( this->LA(1) )
            	            {
            	            case ATOM:
            	            	{
            	            		switch ( this->LA(2) )
            	            		{
            	            		case 16:
            	            		case 17:
            	            			{
            	            				alt7=1;
            	            			}
            	            		    break;
            	            		case 14:
            	            			{
            	            				alt7=2;
            	            			}
            	            		    break;

            	            		default:
            	            		    if (this->get_backtracking()>0)
            	            		    {
            	            		        this->set_failedflag( true );
            	            		        return ;
            	            		    }

            	            		    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            		    ex->set_decisionNum( 7 );
            	            		    ex->set_state( 1 );


            	            		    goto ruleruleEx;

            	            		}

            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return ;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 7 );
            	                ex->set_state( 0 );


            	                goto ruleruleEx;

            	            }

            	            switch (alt7)
            	            {
            	        	case 1:
            	        	    // Prolog.g:65:52: ATOM
            	        	    {
            	        	         this->matchToken(ATOM, &FOLLOW_ATOM_in_rule333);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleruleEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Prolog.g:65:59: comp_term
            	        	    {
            	        	        this->followPush(FOLLOW_comp_term_in_rule337);
            	        	        comp_term();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleruleEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop8;	/* break out of the loop */
            	    break;
                }
            }
            loop8: ; /* Jump out to here if this rule does not match */


             this->matchToken(17, &FOLLOW_17_in_rule342);
            if  (this->hasException())
            {
                goto ruleruleEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                std::cout << "matched a rule!" << std::endl;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleruleEx; /* Prevent compiler warnings */
    ruleruleEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rule */

/**
 * $ANTLR start query
 * Prolog.g:69:1: query : ( ATOM | comp_term ) ( ',' ( ATOM | comp_term ) )* '.' ;
 */
void
PrologParser::query()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // Prolog.g:69:9: ( ( ATOM | comp_term ) ( ',' ( ATOM | comp_term ) )* '.' )
        // Prolog.g:69:11: ( ATOM | comp_term ) ( ',' ( ATOM | comp_term ) )* '.'
        {
            // Prolog.g:69:11: ( ATOM | comp_term )
            {
                int alt9=2;
                switch ( this->LA(1) )
                {
                case ATOM:
                	{
                		switch ( this->LA(2) )
                		{
                		case 16:
                		case 17:
                			{
                				alt9=1;
                			}
                		    break;
                		case 14:
                			{
                				alt9=2;
                			}
                		    break;

                		default:
                		    if (this->get_backtracking()>0)
                		    {
                		        this->set_failedflag( true );
                		        return ;
                		    }

                		    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		    ex->set_decisionNum( 9 );
                		    ex->set_state( 1 );


                		    goto rulequeryEx;

                		}

                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 9 );
                    ex->set_state( 0 );


                    goto rulequeryEx;

                }

                switch (alt9)
                {
            	case 1:
            	    // Prolog.g:69:12: ATOM
            	    {
            	         this->matchToken(ATOM, &FOLLOW_ATOM_in_query365);
            	        if  (this->hasException())
            	        {
            	            goto rulequeryEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Prolog.g:69:19: comp_term
            	    {
            	        this->followPush(FOLLOW_comp_term_in_query369);
            	        comp_term();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequeryEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // Prolog.g:69:30: ( ',' ( ATOM | comp_term ) )*

            for (;;)
            {
                int alt11=2;
                switch ( this->LA(1) )
                {
                case 16:
                	{
                		alt11=1;
                	}
                    break;

                }

                switch (alt11)
                {
            	case 1:
            	    // Prolog.g:69:31: ',' ( ATOM | comp_term )
            	    {
            	         this->matchToken(16, &FOLLOW_16_in_query373);
            	        if  (this->hasException())
            	        {
            	            goto rulequeryEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // Prolog.g:69:35: ( ATOM | comp_term )
            	        {
            	            int alt10=2;
            	            switch ( this->LA(1) )
            	            {
            	            case ATOM:
            	            	{
            	            		switch ( this->LA(2) )
            	            		{
            	            		case 16:
            	            		case 17:
            	            			{
            	            				alt10=1;
            	            			}
            	            		    break;
            	            		case 14:
            	            			{
            	            				alt10=2;
            	            			}
            	            		    break;

            	            		default:
            	            		    if (this->get_backtracking()>0)
            	            		    {
            	            		        this->set_failedflag( true );
            	            		        return ;
            	            		    }

            	            		    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            		    ex->set_decisionNum( 10 );
            	            		    ex->set_state( 1 );


            	            		    goto rulequeryEx;

            	            		}

            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return ;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 10 );
            	                ex->set_state( 0 );


            	                goto rulequeryEx;

            	            }

            	            switch (alt10)
            	            {
            	        	case 1:
            	        	    // Prolog.g:69:36: ATOM
            	        	    {
            	        	         this->matchToken(ATOM, &FOLLOW_ATOM_in_query376);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequeryEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Prolog.g:69:43: comp_term
            	        	    {
            	        	        this->followPush(FOLLOW_comp_term_in_query380);
            	        	        comp_term();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequeryEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop11;	/* break out of the loop */
            	    break;
                }
            }
            loop11: ; /* Jump out to here if this rule does not match */


             this->matchToken(17, &FOLLOW_17_in_query385);
            if  (this->hasException())
            {
                goto rulequeryEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                std::cout << "matched a query! " << std::endl;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulequeryEx; /* Prevent compiler warnings */
    rulequeryEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end query */

// $ANTLR start synpred1_Prolog
void PrologParser::msynpred1_Prolog_fragment(  )
{
    // Prolog.g:38:12: ( fact )
    // Prolog.g:38:12: fact
    {
        this->followPush(FOLLOW_fact_in_synpred1_Prolog93);
        fact();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred1_PrologEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred1_PrologEx; /* Prevent compiler warnings */
rulesynpred1_PrologEx: ;

}
// $ANTLR end synpred1_Prolog

// $ANTLR start synpred2_Prolog
void PrologParser::msynpred2_Prolog_fragment(  )
{
    // Prolog.g:38:19: ( rule )
    // Prolog.g:38:19: rule
    {
        this->followPush(FOLLOW_rule_in_synpred2_Prolog97);
        rule();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred2_PrologEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred2_PrologEx; /* Prevent compiler warnings */
rulesynpred2_PrologEx: ;

}
// $ANTLR end synpred2_Prolog

// $ANTLR start synpred3_Prolog
void PrologParser::msynpred3_Prolog_fragment(  )
{
    // Prolog.g:38:26: ( query )
    // Prolog.g:38:26: query
    {
        this->followPush(FOLLOW_query_in_synpred3_Prolog101);
        query();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred3_PrologEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred3_PrologEx; /* Prevent compiler warnings */
rulesynpred3_PrologEx: ;

}
// $ANTLR end synpred3_Prolog
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
bool PrologParser::msynpred( antlr3::ClassForwarder< synpred2_Prolog >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred2_Prolog_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PrologParser::msynpred( antlr3::ClassForwarder< synpred3_Prolog >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred3_Prolog_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PrologParser::msynpred( antlr3::ClassForwarder< synpred1_Prolog >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred1_Prolog_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

	}


/* End of code
 * =============================================================================
 */
