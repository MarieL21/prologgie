/** \file
 *  This C++ source file was generated by $ANTLR version 3.5
 *
 *     -  From the grammar source file : Prolog.g
 *     -                            On : 2013-09-20 05:10:21
 *     -                for the parser : PrologParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "PrologParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

	namespace 	User  {

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   PrologParserTokenNames[13+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "ATOM",
        (ANTLR_UINT8*) "DIGIT",
        (ANTLR_UINT8*) "LOWERCASE",
        (ANTLR_UINT8*) "NUMBER",
        (ANTLR_UINT8*) "PRIME",
        (ANTLR_UINT8*) "SPECIAL",
        (ANTLR_UINT8*) "UNDERSCORE",
        (ANTLR_UINT8*) "UPPERCASE",
        (ANTLR_UINT8*) "VARIABLE",
        (ANTLR_UINT8*) "WS",
        (ANTLR_UINT8*) "'('",
        (ANTLR_UINT8*) "')'",
        (ANTLR_UINT8*) "','"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "Prolog.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* PrologParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new PrologParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PrologParser::PrologParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new PrologParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PrologParser::PrologParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void PrologParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( PrologParserTokenNames );


}

void
PrologParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
PrologParser::~PrologParser()
 {
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return PrologParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_program74_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_program74( FOLLOW_ATOM_in_program74_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_VARIABLE_in_program86_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_VARIABLE_in_program86( FOLLOW_VARIABLE_in_program86_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_NUMBER_in_program98_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_NUMBER_in_program98( FOLLOW_NUMBER_in_program98_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_comp_term_in_program110_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_comp_term_in_program110( FOLLOW_comp_term_in_program110_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_functor_in_comp_term129_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_functor_in_comp_term129( FOLLOW_functor_in_comp_term129_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_14_in_comp_term131_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001090) };
static  PrologParserImplTraits::BitsetListType FOLLOW_14_in_comp_term131( FOLLOW_14_in_comp_term131_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_term_in_comp_term133_bits[]	= { ANTLR_UINT64_LIT(0x0000000000018000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_term_in_comp_term133( FOLLOW_term_in_comp_term133_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_16_in_comp_term136_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001090) };
static  PrologParserImplTraits::BitsetListType FOLLOW_16_in_comp_term136( FOLLOW_16_in_comp_term136_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_term_in_comp_term138_bits[]	= { ANTLR_UINT64_LIT(0x0000000000018000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_term_in_comp_term138( FOLLOW_term_in_comp_term138_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_15_in_comp_term142_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_15_in_comp_term142( FOLLOW_15_in_comp_term142_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_NUMBER_in_term155_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_NUMBER_in_term155( FOLLOW_NUMBER_in_term155_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_VARIABLE_in_term167_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_VARIABLE_in_term167( FOLLOW_VARIABLE_in_term167_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_term179_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_term179( FOLLOW_ATOM_in_term179_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_comp_term_in_term191_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_comp_term_in_term191( FOLLOW_comp_term_in_term191_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_functor208_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_functor208( FOLLOW_ATOM_in_functor208_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start program
 * Prolog.g:30:1: program : ( ATOM | VARIABLE | NUMBER | comp_term );
 */
void
PrologParser::program()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  Prolog.g:30:9: ( ATOM | VARIABLE | NUMBER | comp_term )

            ANTLR_UINT32 alt1;

            alt1=4;

            switch ( this->LA(1) )
            {
            case ATOM:
            	{
            		switch ( this->LA(2) )
            		{
            		case EOF:
            			{
            				alt1=1;
            			}
            		    break;
            		case 14:
            			{
            				alt1=4;
            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 1 );
            		    ex->set_state( 1 );


            		    goto ruleprogramEx;

            		}

            	}
                break;
            case VARIABLE:
            	{
            		alt1=2;
            	}
                break;
            case NUMBER:
            	{
            		alt1=3;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 1 );
                ex->set_state( 0 );


                goto ruleprogramEx;

            }

            switch (alt1)
            {
        	case 1:
        	    // Prolog.g:30:11: ATOM
        	    {
        	         this->matchToken(ATOM, &FOLLOW_ATOM_in_program74);
        	        if  (this->hasException())
        	        {
        	            goto ruleprogramEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Prolog.g:31:11: VARIABLE
        	    {
        	         this->matchToken(VARIABLE, &FOLLOW_VARIABLE_in_program86);
        	        if  (this->hasException())
        	        {
        	            goto ruleprogramEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Prolog.g:32:11: NUMBER
        	    {
        	         this->matchToken(NUMBER, &FOLLOW_NUMBER_in_program98);
        	        if  (this->hasException())
        	        {
        	            goto ruleprogramEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // Prolog.g:33:11: comp_term
        	    {
        	        this->followPush(FOLLOW_comp_term_in_program110);
        	        comp_term();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleprogramEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleprogramEx; /* Prevent compiler warnings */
    ruleprogramEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end program */

/**
 * $ANTLR start comp_term
 * Prolog.g:36:1: comp_term : functor '(' term ( ',' term )* ')' ;
 */
void
PrologParser::comp_term()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // Prolog.g:36:13: ( functor '(' term ( ',' term )* ')' )
        // Prolog.g:36:15: functor '(' term ( ',' term )* ')'
        {
            this->followPush(FOLLOW_functor_in_comp_term129);
            functor();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecomp_termEx;
            }


             this->matchToken(14, &FOLLOW_14_in_comp_term131);
            if  (this->hasException())
            {
                goto rulecomp_termEx;
            }


            this->followPush(FOLLOW_term_in_comp_term133);
            term();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecomp_termEx;
            }


            // Prolog.g:36:32: ( ',' term )*

            for (;;)
            {
                int alt2=2;
                switch ( this->LA(1) )
                {
                case 16:
                	{
                		alt2=1;
                	}
                    break;

                }

                switch (alt2)
                {
            	case 1:
            	    // Prolog.g:36:33: ',' term
            	    {
            	         this->matchToken(16, &FOLLOW_16_in_comp_term136);
            	        if  (this->hasException())
            	        {
            	            goto rulecomp_termEx;
            	        }


            	        this->followPush(FOLLOW_term_in_comp_term138);
            	        term();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecomp_termEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop2;	/* break out of the loop */
            	    break;
                }
            }
            loop2: ; /* Jump out to here if this rule does not match */


             this->matchToken(15, &FOLLOW_15_in_comp_term142);
            if  (this->hasException())
            {
                goto rulecomp_termEx;
            }


            {
                std::cout << "matched comp_term!" << std::endl;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecomp_termEx; /* Prevent compiler warnings */
    rulecomp_termEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end comp_term */

/**
 * $ANTLR start term
 * Prolog.g:38:1: term : ( NUMBER | VARIABLE | ATOM | comp_term );
 */
void
PrologParser::term()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  Prolog.g:38:9: ( NUMBER | VARIABLE | ATOM | comp_term )

            ANTLR_UINT32 alt3;

            alt3=4;

            switch ( this->LA(1) )
            {
            case NUMBER:
            	{
            		alt3=1;
            	}
                break;
            case VARIABLE:
            	{
            		alt3=2;
            	}
                break;
            case ATOM:
            	{
            		switch ( this->LA(2) )
            		{
            		case 15:
            		case 16:
            			{
            				alt3=3;
            			}
            		    break;
            		case 14:
            			{
            				alt3=4;
            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 3 );
            		    ex->set_state( 3 );


            		    goto ruletermEx;

            		}

            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 3 );
                ex->set_state( 0 );


                goto ruletermEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // Prolog.g:38:11: NUMBER
        	    {
        	         this->matchToken(NUMBER, &FOLLOW_NUMBER_in_term155);
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Prolog.g:39:11: VARIABLE
        	    {
        	         this->matchToken(VARIABLE, &FOLLOW_VARIABLE_in_term167);
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Prolog.g:40:11: ATOM
        	    {
        	         this->matchToken(ATOM, &FOLLOW_ATOM_in_term179);
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // Prolog.g:41:11: comp_term
        	    {
        	        this->followPush(FOLLOW_comp_term_in_term191);
        	        comp_term();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruletermEx; /* Prevent compiler warnings */
    ruletermEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end term */

/**
 * $ANTLR start functor
 * Prolog.g:44:1: functor : ATOM ;
 */
void
PrologParser::functor()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // Prolog.g:44:9: ( ATOM )
        // Prolog.g:44:11: ATOM
        {
             this->matchToken(ATOM, &FOLLOW_ATOM_in_functor208);
            if  (this->hasException())
            {
                goto rulefunctorEx;
            }


            {
                std::cout << "matched functor!" << std::endl;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunctorEx; /* Prevent compiler warnings */
    rulefunctorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end functor */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

	}


/* End of code
 * =============================================================================
 */
