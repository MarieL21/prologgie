/** \file
 *  This C++ source file was generated by $ANTLR version 3.5
 *
 *     -  From the grammar source file : Prolog.g
 *     -                            On : 2013-10-26 22:38:11
 *     -                for the parser : PrologParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "PrologParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

	namespace 	User  {

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   PrologParserTokenNames[16+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "ATOM",
        (ANTLR_UINT8*) "DIGIT",
        (ANTLR_UINT8*) "LOWERCASE",
        (ANTLR_UINT8*) "NUMBER",
        (ANTLR_UINT8*) "PRIME",
        (ANTLR_UINT8*) "SPECIAL",
        (ANTLR_UINT8*) "UNDERSCORE",
        (ANTLR_UINT8*) "UPPERCASE",
        (ANTLR_UINT8*) "VARIABLE",
        (ANTLR_UINT8*) "WS",
        (ANTLR_UINT8*) "'('",
        (ANTLR_UINT8*) "')'",
        (ANTLR_UINT8*) "','",
        (ANTLR_UINT8*) "'.'",
        (ANTLR_UINT8*) "':-'",
        (ANTLR_UINT8*) "'?-'"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "Prolog.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* PrologParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new PrologParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PrologParser::PrologParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new PrologParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PrologParser::PrologParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void PrologParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( PrologParserTokenNames );


}

void
PrologParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
PrologParser::~PrologParser()
 {
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return PrologParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_fact_in_program129_bits[]	= { ANTLR_UINT64_LIT(0x0000000000080012) };
static  PrologParserImplTraits::BitsetListType FOLLOW_fact_in_program129( FOLLOW_fact_in_program129_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_rule_in_program133_bits[]	= { ANTLR_UINT64_LIT(0x0000000000080012) };
static  PrologParserImplTraits::BitsetListType FOLLOW_rule_in_program133( FOLLOW_rule_in_program133_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_query_in_program137_bits[]	= { ANTLR_UINT64_LIT(0x0000000000080012) };
static  PrologParserImplTraits::BitsetListType FOLLOW_query_in_program137( FOLLOW_query_in_program137_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_functor_in_comp_term158_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_functor_in_comp_term158( FOLLOW_functor_in_comp_term158_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_14_in_comp_term160_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001090) };
static  PrologParserImplTraits::BitsetListType FOLLOW_14_in_comp_term160( FOLLOW_14_in_comp_term160_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_term_in_comp_term162_bits[]	= { ANTLR_UINT64_LIT(0x0000000000018000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_term_in_comp_term162( FOLLOW_term_in_comp_term162_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_16_in_comp_term165_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001090) };
static  PrologParserImplTraits::BitsetListType FOLLOW_16_in_comp_term165( FOLLOW_16_in_comp_term165_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_term_in_comp_term167_bits[]	= { ANTLR_UINT64_LIT(0x0000000000018000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_term_in_comp_term167( FOLLOW_term_in_comp_term167_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_15_in_comp_term171_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_15_in_comp_term171( FOLLOW_15_in_comp_term171_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_NUMBER_in_term184_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_NUMBER_in_term184( FOLLOW_NUMBER_in_term184_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_VARIABLE_in_term204_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_VARIABLE_in_term204( FOLLOW_VARIABLE_in_term204_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_term222_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_term222( FOLLOW_ATOM_in_term222_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_comp_term_in_term242_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_comp_term_in_term242( FOLLOW_comp_term_in_term242_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_functor269_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_functor269( FOLLOW_ATOM_in_functor269_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_fact301_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_fact301( FOLLOW_ATOM_in_fact301_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_comp_term_in_fact319_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_comp_term_in_fact319( FOLLOW_comp_term_in_fact319_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_17_in_fact322_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_17_in_fact322( FOLLOW_17_in_fact322_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_rule347_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_rule347( FOLLOW_ATOM_in_rule347_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_comp_term_in_rule351_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_comp_term_in_rule351( FOLLOW_comp_term_in_rule351_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_18_in_rule354_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000010) };
static  PrologParserImplTraits::BitsetListType FOLLOW_18_in_rule354( FOLLOW_18_in_rule354_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_rule357_bits[]	= { ANTLR_UINT64_LIT(0x0000000000030000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_rule357( FOLLOW_ATOM_in_rule357_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_comp_term_in_rule361_bits[]	= { ANTLR_UINT64_LIT(0x0000000000030000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_comp_term_in_rule361( FOLLOW_comp_term_in_rule361_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_16_in_rule365_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000010) };
static  PrologParserImplTraits::BitsetListType FOLLOW_16_in_rule365( FOLLOW_16_in_rule365_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_rule368_bits[]	= { ANTLR_UINT64_LIT(0x0000000000030000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_rule368( FOLLOW_ATOM_in_rule368_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_comp_term_in_rule372_bits[]	= { ANTLR_UINT64_LIT(0x0000000000030000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_comp_term_in_rule372( FOLLOW_comp_term_in_rule372_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_17_in_rule377_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_17_in_rule377( FOLLOW_17_in_rule377_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_19_in_query414_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000010) };
static  PrologParserImplTraits::BitsetListType FOLLOW_19_in_query414( FOLLOW_19_in_query414_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_ATOM_in_query419_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_ATOM_in_query419( FOLLOW_ATOM_in_query419_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_comp_term_in_query435_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  PrologParserImplTraits::BitsetListType FOLLOW_comp_term_in_query435( FOLLOW_comp_term_in_query435_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_17_in_query437_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_17_in_query437( FOLLOW_17_in_query437_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_fact_in_synpred1_Prolog129_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_fact_in_synpred1_Prolog129( FOLLOW_fact_in_synpred1_Prolog129_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PrologParser  */
static	ANTLR_BITWORD FOLLOW_rule_in_synpred2_Prolog133_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PrologParserImplTraits::BitsetListType FOLLOW_rule_in_synpred2_Prolog133( FOLLOW_rule_in_synpred2_Prolog133_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start program
 * Prolog.g:62:1: program : ( fact | rule | query )+ ;
 */
void
PrologParser::program()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // Prolog.g:63:9: ( ( fact | rule | query )+ )
        // Prolog.g:63:11: ( fact | rule | query )+
        {
            // Prolog.g:63:11: ( fact | rule | query )+
            {
                int cnt1=0;

                for (;;)
                {
                    int alt1=4;
            	switch ( this->LA(1) )
            	{
            	case ATOM:
            		{
            			{
            			   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            			    */
            			    int LA1_2 = this->LA(2);
            			    if ( (this->msynpred( antlr3::ClassForwarder<synpred1_Prolog>() )))
            			    {
            			        alt1=1;
            			    }
            			    else if ( (this->msynpred( antlr3::ClassForwarder<synpred2_Prolog>() )))
            			    {
            			        alt1=2;
            			    }

            			}
            		}
            	    break;
            	case 19:
            		{
            			alt1=3;
            		}
            	    break;

            	}

            	switch (alt1)
            	{
            	    case 1:
            	        // Prolog.g:63:12: fact
            	        {
            	            this->followPush(FOLLOW_fact_in_program129);
            	            fact();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleprogramEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;
            	    case 2:
            	        // Prolog.g:63:19: rule
            	        {
            	            this->followPush(FOLLOW_rule_in_program133);
            	            rule();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleprogramEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;
            	    case 3:
            	        // Prolog.g:63:26: query
            	        {
            	            this->followPush(FOLLOW_query_in_program137);
            	            query();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleprogramEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt1 >= 1 )
            		{
            		    goto loop1;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PrologParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleprogramEx;
            	}
            	cnt1++;
                }
                loop1: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprogramEx; /* Prevent compiler warnings */
    ruleprogramEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end program */

/**
 * $ANTLR start comp_term
 * Prolog.g:66:1: comp_term : functor '(' term ( ',' term )* ')' ;
 */
void
PrologParser::comp_term()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // Prolog.g:66:13: ( functor '(' term ( ',' term )* ')' )
        // Prolog.g:66:15: functor '(' term ( ',' term )* ')'
        {
            this->followPush(FOLLOW_functor_in_comp_term158);
            functor();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecomp_termEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(14, &FOLLOW_14_in_comp_term160);
            if  (this->hasException())
            {
                goto rulecomp_termEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_term_in_comp_term162);
            term();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecomp_termEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // Prolog.g:66:32: ( ',' term )*

            for (;;)
            {
                int alt2=2;
                switch ( this->LA(1) )
                {
                case 16:
                	{
                		alt2=1;
                	}
                    break;

                }

                switch (alt2)
                {
            	case 1:
            	    // Prolog.g:66:33: ',' term
            	    {
            	         this->matchToken(16, &FOLLOW_16_in_comp_term165);
            	        if  (this->hasException())
            	        {
            	            goto rulecomp_termEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_term_in_comp_term167);
            	        term();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecomp_termEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop2;	/* break out of the loop */
            	    break;
                }
            }
            loop2: ; /* Jump out to here if this rule does not match */


             this->matchToken(15, &FOLLOW_15_in_comp_term171);
            if  (this->hasException())
            {
                goto rulecomp_termEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecomp_termEx; /* Prevent compiler warnings */
    rulecomp_termEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end comp_term */

/**
 * $ANTLR start term
 * Prolog.g:68:1: term : (n= NUMBER |v= VARIABLE |a= ATOM | comp_term );
 */
void
PrologParser::term()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    n;
    const CommonTokenType*    v;
    const CommonTokenType*    a;

    /* Initialize rule variables
     */

    n       = NULL;
    v       = NULL;
    a       = NULL;


 
    {
        {
            //  Prolog.g:68:9: (n= NUMBER |v= VARIABLE |a= ATOM | comp_term )

            ANTLR_UINT32 alt3;

            alt3=4;

            switch ( this->LA(1) )
            {
            case NUMBER:
            	{
            		alt3=1;
            	}
                break;
            case VARIABLE:
            	{
            		alt3=2;
            	}
                break;
            case ATOM:
            	{
            		switch ( this->LA(2) )
            		{
            		case EOF:
            		case 15:
            		case 16:
            			{
            				alt3=3;
            			}
            		    break;
            		case 14:
            			{
            				alt3=4;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 3 );
            		    ex->set_state( 3 );


            		    goto ruletermEx;

            		}

            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 3 );
                ex->set_state( 0 );


                goto ruletermEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // Prolog.g:68:11: n= NUMBER
        	    {
        	        n =  this->matchToken(NUMBER, &FOLLOW_NUMBER_in_term184);
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Prolog.g:69:11: v= VARIABLE
        	    {
        	        v =  this->matchToken(VARIABLE, &FOLLOW_VARIABLE_in_term204);
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Prolog.g:70:11: a= ATOM
        	    {
        	        a =  this->matchToken(ATOM, &FOLLOW_ATOM_in_term222);
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // Prolog.g:71:11: comp_term
        	    {
        	        this->followPush(FOLLOW_comp_term_in_term242);
        	        comp_term();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletermEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruletermEx; /* Prevent compiler warnings */
    ruletermEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end term */

/**
 * $ANTLR start functor
 * Prolog.g:74:1: functor : a= ATOM ;
 */
void
PrologParser::functor()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    a;

    /* Initialize rule variables
     */

    a       = NULL;


 
    {
        // Prolog.g:74:9: (a= ATOM )
        // Prolog.g:74:11: a= ATOM
        {
            a =  this->matchToken(ATOM, &FOLLOW_ATOM_in_functor269);
            if  (this->hasException())
            {
                goto rulefunctorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunctorEx; /* Prevent compiler warnings */
    rulefunctorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end functor */

/**
 * $ANTLR start fact
 * Prolog.g:78:1: fact : (a= ATOM | comp_term ) '.' ;
 */
void
PrologParser::fact()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    a;

    /* Initialize rule variables
     */

    a       = NULL;


 
    {
        // Prolog.g:78:9: ( (a= ATOM | comp_term ) '.' )
        // Prolog.g:78:11: (a= ATOM | comp_term ) '.'
        {
            // Prolog.g:78:11: (a= ATOM | comp_term )
            {
                int alt4=2;
                switch ( this->LA(1) )
                {
                case ATOM:
                	{
                		switch ( this->LA(2) )
                		{
                		case 17:
                			{
                				alt4=1;
                			}
                		    break;
                		case 14:
                			{
                				alt4=2;
                			}
                		    break;

                		default:
                		    if (this->get_backtracking()>0)
                		    {
                		        this->set_failedflag( true );
                		        return ;
                		    }

                		    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		    ex->set_decisionNum( 4 );
                		    ex->set_state( 1 );


                		    goto rulefactEx;

                		}

                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 4 );
                    ex->set_state( 0 );


                    goto rulefactEx;

                }

                switch (alt4)
                {
            	case 1:
            	    // Prolog.g:78:12: a= ATOM
            	    {
            	        a =  this->matchToken(ATOM, &FOLLOW_ATOM_in_fact301);
            	        if  (this->hasException())
            	        {
            	            goto rulefactEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Prolog.g:79:11: comp_term
            	    {
            	        this->followPush(FOLLOW_comp_term_in_fact319);
            	        comp_term();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefactEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(17, &FOLLOW_17_in_fact322);
            if  (this->hasException())
            {
                goto rulefactEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                std::cout << "matched a fact!" << std::endl;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefactEx; /* Prevent compiler warnings */
    rulefactEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end fact */

/**
 * $ANTLR start rule
 * Prolog.g:84:1: rule : ( ATOM | comp_term ) ':-' ( ATOM | comp_term ) ( ',' ( ATOM | comp_term ) )* '.' ;
 */
void
PrologParser::rule()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // Prolog.g:84:9: ( ( ATOM | comp_term ) ':-' ( ATOM | comp_term ) ( ',' ( ATOM | comp_term ) )* '.' )
        // Prolog.g:84:11: ( ATOM | comp_term ) ':-' ( ATOM | comp_term ) ( ',' ( ATOM | comp_term ) )* '.'
        {
            // Prolog.g:84:11: ( ATOM | comp_term )
            {
                int alt5=2;
                switch ( this->LA(1) )
                {
                case ATOM:
                	{
                		switch ( this->LA(2) )
                		{
                		case 18:
                			{
                				alt5=1;
                			}
                		    break;
                		case 14:
                			{
                				alt5=2;
                			}
                		    break;

                		default:
                		    if (this->get_backtracking()>0)
                		    {
                		        this->set_failedflag( true );
                		        return ;
                		    }

                		    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		    ex->set_decisionNum( 5 );
                		    ex->set_state( 1 );


                		    goto ruleruleEx;

                		}

                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 5 );
                    ex->set_state( 0 );


                    goto ruleruleEx;

                }

                switch (alt5)
                {
            	case 1:
            	    // Prolog.g:84:12: ATOM
            	    {
            	         this->matchToken(ATOM, &FOLLOW_ATOM_in_rule347);
            	        if  (this->hasException())
            	        {
            	            goto ruleruleEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Prolog.g:84:19: comp_term
            	    {
            	        this->followPush(FOLLOW_comp_term_in_rule351);
            	        comp_term();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleruleEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(18, &FOLLOW_18_in_rule354);
            if  (this->hasException())
            {
                goto ruleruleEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // Prolog.g:84:35: ( ATOM | comp_term )
            {
                int alt6=2;
                switch ( this->LA(1) )
                {
                case ATOM:
                	{
                		switch ( this->LA(2) )
                		{
                		case 16:
                		case 17:
                			{
                				alt6=1;
                			}
                		    break;
                		case 14:
                			{
                				alt6=2;
                			}
                		    break;

                		default:
                		    if (this->get_backtracking()>0)
                		    {
                		        this->set_failedflag( true );
                		        return ;
                		    }

                		    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		    ex->set_decisionNum( 6 );
                		    ex->set_state( 1 );


                		    goto ruleruleEx;

                		}

                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 6 );
                    ex->set_state( 0 );


                    goto ruleruleEx;

                }

                switch (alt6)
                {
            	case 1:
            	    // Prolog.g:84:36: ATOM
            	    {
            	         this->matchToken(ATOM, &FOLLOW_ATOM_in_rule357);
            	        if  (this->hasException())
            	        {
            	            goto ruleruleEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Prolog.g:84:43: comp_term
            	    {
            	        this->followPush(FOLLOW_comp_term_in_rule361);
            	        comp_term();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleruleEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // Prolog.g:84:54: ( ',' ( ATOM | comp_term ) )*

            for (;;)
            {
                int alt8=2;
                switch ( this->LA(1) )
                {
                case 16:
                	{
                		alt8=1;
                	}
                    break;

                }

                switch (alt8)
                {
            	case 1:
            	    // Prolog.g:84:55: ',' ( ATOM | comp_term )
            	    {
            	         this->matchToken(16, &FOLLOW_16_in_rule365);
            	        if  (this->hasException())
            	        {
            	            goto ruleruleEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // Prolog.g:84:59: ( ATOM | comp_term )
            	        {
            	            int alt7=2;
            	            switch ( this->LA(1) )
            	            {
            	            case ATOM:
            	            	{
            	            		switch ( this->LA(2) )
            	            		{
            	            		case 16:
            	            		case 17:
            	            			{
            	            				alt7=1;
            	            			}
            	            		    break;
            	            		case 14:
            	            			{
            	            				alt7=2;
            	            			}
            	            		    break;

            	            		default:
            	            		    if (this->get_backtracking()>0)
            	            		    {
            	            		        this->set_failedflag( true );
            	            		        return ;
            	            		    }

            	            		    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            		    ex->set_decisionNum( 7 );
            	            		    ex->set_state( 1 );


            	            		    goto ruleruleEx;

            	            		}

            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return ;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 7 );
            	                ex->set_state( 0 );


            	                goto ruleruleEx;

            	            }

            	            switch (alt7)
            	            {
            	        	case 1:
            	        	    // Prolog.g:84:60: ATOM
            	        	    {
            	        	         this->matchToken(ATOM, &FOLLOW_ATOM_in_rule368);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleruleEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Prolog.g:84:67: comp_term
            	        	    {
            	        	        this->followPush(FOLLOW_comp_term_in_rule372);
            	        	        comp_term();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleruleEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop8;	/* break out of the loop */
            	    break;
                }
            }
            loop8: ; /* Jump out to here if this rule does not match */


             this->matchToken(17, &FOLLOW_17_in_rule377);
            if  (this->hasException())
            {
                goto ruleruleEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                std::cout << "matched a rule!" << std::endl;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleruleEx; /* Prevent compiler warnings */
    ruleruleEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rule */

/**
 * $ANTLR start query
 * Prolog.g:89:1: query : '?-' (a= ATOM | comp_term ) '.' ;
 */
void
PrologParser::query()
{
        PrologParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    a;

    /* Initialize rule variables
     */
    m_TmpScope_stack.push(TmpScopeScope()); 

    a       = NULL;


 
    {
        // Prolog.g:91:9: ( '?-' (a= ATOM | comp_term ) '.' )
        // Prolog.g:91:11: '?-' (a= ATOM | comp_term ) '.'
        {
             this->matchToken(19, &FOLLOW_19_in_query414);
            if  (this->hasException())
            {
                goto rulequeryEx;
            }
            if (this->hasFailed())
            {
                m_TmpScope_stack.pop(); 

                return ;
            }


            // Prolog.g:91:16: (a= ATOM | comp_term )
            {
                int alt9=2;
                switch ( this->LA(1) )
                {
                case ATOM:
                	{
                		switch ( this->LA(2) )
                		{
                		case 17:
                			{
                				alt9=1;
                			}
                		    break;
                		case 14:
                			{
                				alt9=2;
                			}
                		    break;

                		default:
                		    if (this->get_backtracking()>0)
                		    {
                		        this->set_failedflag( true );
                		        m_TmpScope_stack.pop(); 

                		        return ;
                		    }

                		    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		    ex->set_decisionNum( 9 );
                		    ex->set_state( 1 );


                		    goto rulequeryEx;

                		}

                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        m_TmpScope_stack.pop(); 

                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PrologParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 9 );
                    ex->set_state( 0 );


                    goto rulequeryEx;

                }

                switch (alt9)
                {
            	case 1:
            	    // Prolog.g:91:17: a= ATOM
            	    {
            	        a =  this->matchToken(ATOM, &FOLLOW_ATOM_in_query419);
            	        if  (this->hasException())
            	        {
            	            goto rulequeryEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            m_TmpScope_stack.pop(); 

            	            return ;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            m_TmpScope_stack.peek().temp_map[(a->getText())];
            	        }


            	    }
            	    break;
            	case 2:
            	    // Prolog.g:92:11: comp_term
            	    {
            	        this->followPush(FOLLOW_comp_term_in_query435);
            	        comp_term();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequeryEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            m_TmpScope_stack.pop(); 

            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(17, &FOLLOW_17_in_query437);
            if  (this->hasException())
            {
                goto rulequeryEx;
            }
            if (this->hasFailed())
            {
                m_TmpScope_stack.pop(); 

                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                std::cout << "matched a query! " << std::endl;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulequeryEx; /* Prevent compiler warnings */
    rulequeryEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    m_TmpScope_stack.pop(); 

    return ;
}
/* $ANTLR end query */

// $ANTLR start synpred1_Prolog
void PrologParser::msynpred1_Prolog_fragment(  )
{
    // Prolog.g:63:12: ( fact )
    // Prolog.g:63:12: fact
    {
        this->followPush(FOLLOW_fact_in_synpred1_Prolog129);
        fact();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred1_PrologEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred1_PrologEx; /* Prevent compiler warnings */
rulesynpred1_PrologEx: ;

}
// $ANTLR end synpred1_Prolog

// $ANTLR start synpred2_Prolog
void PrologParser::msynpred2_Prolog_fragment(  )
{
    // Prolog.g:63:19: ( rule )
    // Prolog.g:63:19: rule
    {
        this->followPush(FOLLOW_rule_in_synpred2_Prolog133);
        rule();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred2_PrologEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred2_PrologEx; /* Prevent compiler warnings */
rulesynpred2_PrologEx: ;

}
// $ANTLR end synpred2_Prolog
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
bool PrologParser::msynpred( antlr3::ClassForwarder< synpred2_Prolog >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred2_Prolog_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PrologParser::msynpred( antlr3::ClassForwarder< synpred1_Prolog >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred1_Prolog_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

	}


/* End of code
 * =============================================================================
 */
